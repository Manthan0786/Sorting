{"ast":null,"code":"export default function Mergesort(array) {\n  //calling original array\n  var animation = [];\n  if (array.length <= 1) {\n    return array;\n  }\n  mergesortHelper(array, 0, array.length - 1, animation);\n  return animation; //returning animations for visualization\n}\n_c = Mergesort;\nfunction mergesortHelper(array, startindex, endindex, animation) {\n  if (startindex >= endindex) {\n    return;\n  }\n  var mid = Math.floor((startindex + endindex) / 2); //dividing array in two parts\n  mergesortHelper(array, startindex, mid, animation); // recrusion steps\n  mergesortHelper(array, mid + 1, endindex, animation);\n  merge(array, startindex, mid, endindex, animation); // merging sorted arrays\n}\n\nfunction merge(array, startindex, mid, endindex, animation) {\n  var l = startindex;\n  var k = startindex;\n  var r = mid + 1;\n  var mainArray = [];\n  while (l <= mid && r <= endindex) {\n    animation.push([l, r]); //Comparing value at ith and jth index so push them to change their color\n    animation.push([l, r]); //By changing color we imply that we are comparing those two values and then again we should revert back to other color, so push them again\n    if (array[l] <= array[r]) {\n      //if condition satisfies,\n      animation.push([k, array[l]]); // We overwrite the value at index k in the new array with the\n      mainArray[k] = array[l]; // value at index l in the original array.\n      k++;\n      l++;\n    } else {\n      animation.push([k, array[r]]); // We overwrite the value at index k in the new array with the\n      mainArray[k] = array[r]; // value at index r in the original array.\n      k++;\n      r++;\n    }\n  }\n  while (l <= mid) {\n    animation.push([l, l]); //We are comparing thses two values and changing their color\n    animation.push([l, l]); //comparing again and revert them to seconday color\n    animation.push([k, array[l]]);\n    mainArray[k] = array[l];\n    k++;\n    l++;\n  }\n  while (r <= endindex) {\n    animation.push([r, r]); //We are comparing thses two values and changing their color\n    animation.push([r, r]); //comparing again and revert them to seconday color\n    animation.push([k, array[r]]);\n    mainArray[k] = array[r];\n    k++;\n    r++;\n  }\n  for (var i = startindex; i <= endindex; i++) {\n    //again pushing values of new array to original array\n    array[i] = mainArray[i];\n  }\n}\nvar _c;\n$RefreshReg$(_c, \"Mergesort\");","map":{"version":3,"names":["Mergesort","array","animation","length","mergesortHelper","_c","startindex","endindex","mid","Math","floor","merge","l","k","r","mainArray","push","i","$RefreshReg$"],"sources":["C:/Users/18253/OneDrive/Documents/GitHub/Sorting-Visualizer/src/SortingAlgorithms/MergeSort.js"],"sourcesContent":["export default function Mergesort(array) {\r\n  //calling original array\r\n  const animation = [];\r\n  if (array.length <= 1) {\r\n    return array;\r\n  }\r\n  mergesortHelper(array, 0, array.length - 1, animation);\r\n  return animation; //returning animations for visualization\r\n}\r\n\r\nfunction mergesortHelper(array, startindex, endindex, animation) {\r\n  if (startindex >= endindex) {\r\n    return;\r\n  }\r\n  const mid = Math.floor((startindex + endindex) / 2); //dividing array in two parts\r\n  mergesortHelper(array, startindex, mid, animation); // recrusion steps\r\n  mergesortHelper(array, mid + 1, endindex, animation);\r\n  merge(array, startindex, mid, endindex, animation); // merging sorted arrays\r\n}\r\n\r\nfunction merge(array, startindex, mid, endindex, animation) {\r\n  let l = startindex;\r\n  let k = startindex;\r\n  let r = mid + 1;\r\n  let mainArray = [];\r\n  while (l <= mid && r <= endindex) {\r\n    animation.push([l, r]); //Comparing value at ith and jth index so push them to change their color\r\n    animation.push([l, r]); //By changing color we imply that we are comparing those two values and then again we should revert back to other color, so push them again\r\n    if (array[l] <= array[r]) {\r\n      //if condition satisfies,\r\n      animation.push([k, array[l]]); // We overwrite the value at index k in the new array with the\r\n      mainArray[k] = array[l]; // value at index l in the original array.\r\n      k++;\r\n      l++;\r\n    } else {\r\n      animation.push([k, array[r]]); // We overwrite the value at index k in the new array with the\r\n      mainArray[k] = array[r]; // value at index r in the original array.\r\n      k++;\r\n      r++;\r\n    }\r\n  }\r\n  while (l <= mid) {\r\n    animation.push([l, l]); //We are comparing thses two values and changing their color\r\n    animation.push([l, l]); //comparing again and revert them to seconday color\r\n    animation.push([k, array[l]]);\r\n    mainArray[k] = array[l];\r\n    k++;\r\n    l++;\r\n  }\r\n  while (r <= endindex) {\r\n    animation.push([r, r]); //We are comparing thses two values and changing their color\r\n    animation.push([r, r]); //comparing again and revert them to seconday color\r\n    animation.push([k, array[r]]);\r\n    mainArray[k] = array[r];\r\n    k++;\r\n    r++;\r\n  }\r\n\r\n  for (var i = startindex; i <= endindex; i++) {\r\n    //again pushing values of new array to original array\r\n    array[i] = mainArray[i];\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}